/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nhtml, body {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;\n    background: #f7fafc;\n}\n\n#app {\n    width: 100vw;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    overflow: hidden;\n}\n\n.toolbar {\n    background: #2d3748;\n    padding: 15px 20px;\n    display: flex;\n    gap: 15px;\n    align-items: center;\n    flex-wrap: wrap;\n    flex-shrink: 0;\n}\n\n.resolution-controls {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-left: auto;\n    color: white;\n}\n\n.resolution-controls label {\n    font-size: 14px;\n}\n\n.resolution-controls input[type=\"number\"] {\n    width: 80px;\n    padding: 5px;\n    border: 1px solid #4a5568;\n    border-radius: 4px;\n    background: #1a202c;\n    color: white;\n    text-align: center;\n}\n\n.resolution-controls span {\n    color: #cbd5e0;\n}\n\n.resolution-select {\n    padding: 5px 10px;\n    border: 1px solid #4a5568;\n    border-radius: 4px;\n    background: #1a202c;\n    color: white;\n    cursor: pointer;\n}\n\n.tool-btn {\n    background: #4a5568;\n    color: white;\n    border: none;\n    padding: 10px 20px;\n    border-radius: 6px;\n    cursor: pointer;\n    font-size: 14px;\n    transition: all 0.3s ease;\n}\n\n.tool-btn:hover {\n    background: #718096;\n    transform: translateY(-2px);\n}\n\n.tool-btn.danger {\n    background: #e53e3e;\n}\n\n.tool-btn.danger:hover {\n    background: #fc8181;\n}\n\n.tool-btn.primary {\n    background: #3182ce;\n}\n\n.tool-btn.primary:hover {\n    background: #4299e1;\n}\n\n.toolbar-separator {\n    width: 1px;\n    height: 30px;\n    background: #4a5568;\n    margin: 0 10px;\n}\n\n.canvas-area {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.canvas-container {\n    flex: 1;\n    background: #f7fafc;\n    display: flex;\n    overflow-x: auto;\n    overflow-y: auto;\n    padding: 20px;\n    gap: 20px;\n}\n\n.canvas-wrapper {\n    flex-shrink: 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n    padding: 10px;\n    margin: 0;\n}\n\n.canvas-wrapper.active {\n    box-shadow: 0 0 0 3px #3182ce, 0 2px 8px rgba(0,0,0,0.2);\n}\n\n.canvas-title {\n    margin-bottom: 10px;\n    padding: 5px 10px;\n    background: #f7fafc;\n    border-radius: 4px;\n    font-size: 14px;\n    color: #2d3748;\n    cursor: text;\n    min-width: 100px;\n    text-align: center;\n}\n\n.canvas-wrapper canvas {\n    background: white;\n    cursor: default;\n    image-rendering: crisp-edges;\n    image-rendering: -moz-crisp-edges;\n    image-rendering: -webkit-optimize-contrast;\n}\n\n.canvas-container.dragging {\n    background: #e2e8f0;\n}\n\n.canvas-element {\n    position: absolute;\n    cursor: move;\n    border: 2px solid transparent;\n    padding: 5px;\n    user-select: none;\n}\n\n.canvas-element:hover {\n    border-color: #4299e1;\n}\n\n.canvas-element.selected {\n    border-color: #3182ce;\n    box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);\n}\n\n.canvas-element.text {\n    font-size: 24px;\n    color: #2d3748;\n    background: transparent;\n    min-width: 100px;\n    min-height: 30px;\n}\n\n.canvas-element.image {\n    max-width: 300px;\n    max-height: 300px;\n}\n\n.canvas-element img {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n}\n\n.resize-handle {\n    position: absolute;\n    width: 10px;\n    height: 10px;\n    background: #3182ce;\n    border: 2px solid white;\n    border-radius: 50%;\n}\n\n.resize-handle.bottom-right {\n    bottom: -5px;\n    right: -5px;\n    cursor: nwse-resize;\n}\n\n.delete-btn {\n    position: absolute;\n    top: -10px;\n    right: -10px;\n    width: 20px;\n    height: 20px;\n    background: #e53e3e;\n    color: white;\n    border: none;\n    border-radius: 50%;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 12px;\n    line-height: 1;\n}\n\n.delete-btn:hover {\n    background: #fc8181;\n}\n\n.text-toolbar {\n    background: #4a5568;\n    padding: 12px 15px;\n    border-bottom: 1px solid #2d3748;\n    flex-shrink: 0;\n}\n\n.text-controls {\n    display: flex;\n    gap: 15px;\n    align-items: center;\n    justify-content: center;\n}\n\n.text-select {\n    padding: 5px 10px;\n    border: 1px solid #2d3748;\n    border-radius: 4px;\n    background: #2d3748;\n    color: white;\n    cursor: pointer;\n}\n\n.font-size-input {\n    width: 60px;\n    padding: 5px;\n    border: 1px solid #2d3748;\n    border-radius: 4px;\n    background: #2d3748;\n    color: white;\n    text-align: center;\n}\n\n.format-btn {\n    width: 30px;\n    height: 30px;\n    border: none;\n    border-radius: 4px;\n    background: #2d3748;\n    color: white;\n    font-weight: bold;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.format-btn.italic {\n    font-style: italic;\n}\n\n.format-btn:hover,\n.format-btn.active {\n    background: #3182ce;\n}\n\n.align-group {\n    display: flex;\n    gap: 5px;\n    background: #2d3748;\n    padding: 3px;\n    border-radius: 4px;\n}\n\n.align-btn {\n    width: 30px;\n    height: 26px;\n    border: none;\n    background: transparent;\n    color: white;\n    cursor: pointer;\n    border-radius: 3px;\n    transition: all 0.2s;\n}\n\n.align-btn:hover,\n.align-btn.active {\n    background: #3182ce;\n}\n\n.color-picker {\n    width: 40px;\n    height: 30px;\n    border: 1px solid #2d3748;\n    border-radius: 4px;\n    cursor: pointer;\n}\n\n.resize-handle {\n    position: absolute;\n    width: 8px;\n    height: 8px;\n    background: #3182ce;\n    border: 1px solid white;\n    border-radius: 2px;\n    cursor: pointer;\n}\n\n.resize-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }\n.resize-handle.n { top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; }\n.resize-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }\n.resize-handle.e { top: 50%; right: -4px; transform: translateY(-50%); cursor: e-resize; }\n.resize-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }\n.resize-handle.s { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; }\n.resize-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }\n.resize-handle.w { top: 50%; left: -4px; transform: translateY(-50%); cursor: w-resize; }\n\n.context-menu {\n    position: fixed;\n    background: white;\n    border: 1px solid #e2e8f0;\n    border-radius: 6px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n    padding: 4px 0;\n    z-index: 10000;\n    min-width: 200px;\n    font-size: 13px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n}\n\n.context-menu-item {\n    padding: 8px 12px;\n    cursor: pointer;\n    transition: background-color 0.1s;\n    display: flex;\n    align-items: center;\n    color: #2d3748;\n    position: relative;\n}\n\n.context-menu-item:hover {\n    background-color: #3182ce;\n    color: white;\n}\n\n.context-menu-item span:first-child {\n    width: 20px;\n    text-align: center;\n    margin-right: 8px;\n}\n\n.context-menu-item .shortcut {\n    margin-left: auto;\n    opacity: 0.6;\n    font-size: 11px;\n    padding-left: 20px;\n}\n\n.context-menu-item:hover .shortcut {\n    opacity: 0.9;\n}\n\n.context-menu-separator {\n    height: 1px;\n    background-color: #e2e8f0;\n    margin: 4px 0;\n}\n\n.context-menu-item.has-submenu {\n    position: relative;\n    padding-right: 25px;\n}\n\n.context-menu-item .submenu-arrow {\n    position: absolute;\n    right: 8px;\n    opacity: 0.5;\n    width: auto;\n    margin: 0;\n}\n\n.context-submenu {\n    position: absolute;\n    left: 100%;\n    top: -4px;\n    background: white;\n    border: 1px solid #e2e8f0;\n    border-radius: 6px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n    padding: 4px 0;\n    min-width: 180px;\n    display: none;\n}\n\n.context-menu-item.has-submenu:hover .context-submenu {\n    display: block;\n}\n\n.context-submenu .context-menu-item {\n    padding: 8px 12px;\n}\n\n.context-submenu .context-menu-item:hover {\n    background-color: #3182ce;\n    color: white;\n}\n\n.thumbnail-bar {\n    height: 120px;\n    background: #2d3748;\n    border-top: 1px solid #1a202c;\n    display: flex;\n    align-items: center;\n    padding: 10px 20px;\n    overflow-x: auto;\n    flex-shrink: 0;\n}\n\n.thumbnail-container {\n    display: flex;\n    gap: 15px;\n    height: 100%;\n}\n\n.thumbnail-item {\n    flex-shrink: 0;\n    width: 120px;\n    height: 90px;\n    background: white;\n    border-radius: 6px;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n    cursor: pointer;\n    position: relative;\n    overflow: hidden;\n    transition: all 0.2s;\n}\n\n.thumbnail-item:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 8px rgba(0,0,0,0.3);\n}\n\n.thumbnail-item.active {\n    box-shadow: 0 0 0 3px #3182ce, 0 2px 4px rgba(0,0,0,0.2);\n}\n\n.thumbnail-canvas {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n}\n\n.thumbnail-label {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    background: rgba(0,0,0,0.7);\n    color: white;\n    padding: 2px 5px;\n    font-size: 11px;\n    text-align: center;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.thumbnail-delete {\n    position: absolute;\n    top: 5px;\n    right: 5px;\n    width: 20px;\n    height: 20px;\n    background: #e53e3e;\n    color: white;\n    border: none;\n    border-radius: 50%;\n    cursor: pointer;\n    display: none;\n    align-items: center;\n    justify-content: center;\n    font-size: 12px;\n}\n\n.thumbnail-item:hover .thumbnail-delete {\n    display: flex;\n}\n\n.thumbnail-delete:hover {\n    background: #fc8181;\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/styles.css?./node_modules/css-loader/dist/cjs.js\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("{\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/css-loader/dist/runtime/api.js?\n}");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("{\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/css-loader/dist/runtime/noSourceMaps.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("{\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("{\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/insertBySelector.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/insertStyleElement.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/styleDomAPI.js?\n}");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("{\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://appstorescreenshot/./node_modules/style-loader/dist/runtime/styleTagTransform.js?\n}");

/***/ }),

/***/ "./src/CanvasManager.ts":
/*!******************************!*\
  !*** ./src/CanvasManager.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CanvasManager: () => (/* binding */ CanvasManager)\n/* harmony export */ });\nclass CanvasManager {\n    constructor(canvasId, globalManager, offsetX = 0, offsetY = 0) {\n        this.offsetX = 0; // Canvas offset in global coordinate system\n        this.offsetY = 0;\n        this.scale = 1;\n        this.dragState = {\n            isDragging: false,\n            element: null,\n            startPoint: { x: 0, y: 0 },\n            elementStartPoint: { x: 0, y: 0 }\n        };\n        this.resizeState = {\n            isResizing: false,\n            element: null,\n            handle: null,\n            startPoint: { x: 0, y: 0 },\n            originalBounds: { x: 0, y: 0, width: 0, height: 0 }\n        };\n        this.clipboard = null;\n        this.lastContextMenuPosition = { x: 0, y: 0 };\n        this.canvas = document.getElementById(canvasId);\n        const context = this.canvas.getContext('2d');\n        if (!context) {\n            throw new Error('Failed to get canvas context');\n        }\n        this.ctx = context;\n        this.globalManager = globalManager;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.textToolbar = document.getElementById('textToolbar');\n        this.contextMenu = document.getElementById('contextMenu');\n        this.setupCanvas();\n        this.setupEventListeners();\n        this.setupTextToolbar();\n        this.setupContextMenu();\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    setOffset(offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.render();\n    }\n    // Convert global coordinates to local canvas coordinates\n    globalToLocal(globalX, globalY) {\n        return {\n            x: globalX - this.offsetX,\n            y: globalY - this.offsetY\n        };\n    }\n    // Convert local canvas coordinates to global coordinates\n    localToGlobal(localX, localY) {\n        return {\n            x: localX + this.offsetX,\n            y: localY + this.offsetY\n        };\n    }\n    setupCanvas() {\n        this.setResolution(800, 600);\n    }\n    setResolution(width, height) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        const container = this.canvas.parentElement;\n        if (container) {\n            // Get actual container dimensions (accounting for padding)\n            const containerStyle = window.getComputedStyle(container);\n            const paddingX = parseFloat(containerStyle.paddingLeft) + parseFloat(containerStyle.paddingRight);\n            const paddingY = parseFloat(containerStyle.paddingTop) + parseFloat(containerStyle.paddingBottom);\n            const containerWidth = container.clientWidth - paddingX;\n            const containerHeight = container.clientHeight - paddingY;\n            const scaleX = containerWidth / width;\n            const scaleY = containerHeight / height;\n            this.scale = Math.min(scaleX, scaleY);\n            // Ensure canvas doesn't exceed container\n            if (this.scale > 1) {\n                this.scale = 1; // Don't scale up, only down\n            }\n            this.canvas.style.width = `${width * this.scale}px`;\n            this.canvas.style.height = `${height * this.scale}px`;\n        }\n        this.render();\n    }\n    setupEventListeners() {\n        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n        this.canvas.addEventListener('dblclick', this.handleDoubleClick.bind(this));\n        this.canvas.addEventListener('contextmenu', this.handleContextMenu.bind(this));\n        // Hide context menu when clicking elsewhere\n        document.addEventListener('click', (e) => {\n            if (!this.contextMenu.contains(e.target)) {\n                this.contextMenu.style.display = 'none';\n            }\n        });\n        // Keyboard shortcuts\n        document.addEventListener('keydown', (e) => {\n            if (e.ctrlKey || e.metaKey) {\n                if (e.key === 'c') {\n                    e.preventDefault();\n                    this.copyElement();\n                }\n                else if (e.key === 'v') {\n                    e.preventDefault();\n                    this.pasteElement();\n                }\n                else if (e.key === 'd') {\n                    e.preventDefault();\n                    this.duplicateElement();\n                }\n            }\n        });\n    }\n    setupTextToolbar() {\n        const fontFamily = document.getElementById('fontFamily');\n        const fontSize = document.getElementById('fontSize');\n        const boldBtn = document.getElementById('boldBtn');\n        const italicBtn = document.getElementById('italicBtn');\n        const alignLeft = document.getElementById('alignLeft');\n        const alignCenter = document.getElementById('alignCenter');\n        const alignRight = document.getElementById('alignRight');\n        const textColor = document.getElementById('textColor');\n        fontFamily?.addEventListener('change', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, { fontFamily: fontFamily.value });\n                this.render();\n            }\n        });\n        fontSize?.addEventListener('input', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, { fontSize: parseInt(fontSize.value) });\n                this.render();\n            }\n        });\n        boldBtn?.addEventListener('click', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, {\n                    fontWeight: selectedElement.fontWeight === 'bold' ? 'normal' : 'bold'\n                });\n                boldBtn.classList.toggle('active');\n                this.render();\n            }\n        });\n        italicBtn?.addEventListener('click', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, {\n                    fontStyle: selectedElement.fontStyle === 'italic' ? 'normal' : 'italic'\n                });\n                italicBtn.classList.toggle('active');\n                this.render();\n            }\n        });\n        const alignButtons = [alignLeft, alignCenter, alignRight];\n        const alignValues = ['left', 'center', 'right'];\n        alignButtons.forEach((btn, index) => {\n            btn?.addEventListener('click', () => {\n                const selectedElement = this.globalManager.getSelectedElement();\n                if (selectedElement?.type === 'text') {\n                    this.globalManager.updateElement(selectedElement.id, { textAlign: alignValues[index] });\n                    alignButtons.forEach(b => b?.classList.remove('active'));\n                    btn.classList.add('active');\n                    this.render();\n                }\n            });\n        });\n        textColor?.addEventListener('input', () => {\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement?.type === 'text') {\n                this.globalManager.updateElement(selectedElement.id, { color: textColor.value });\n                this.render();\n            }\n        });\n    }\n    updateTextToolbar() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement?.type === 'text') {\n            this.textToolbar.style.display = 'block';\n            const fontFamily = document.getElementById('fontFamily');\n            const fontSize = document.getElementById('fontSize');\n            const boldBtn = document.getElementById('boldBtn');\n            const italicBtn = document.getElementById('italicBtn');\n            const textColor = document.getElementById('textColor');\n            const alignButtons = [\n                document.getElementById('alignLeft'),\n                document.getElementById('alignCenter'),\n                document.getElementById('alignRight')\n            ];\n            if (fontFamily)\n                fontFamily.value = selectedElement.fontFamily || 'Arial';\n            if (fontSize)\n                fontSize.value = (selectedElement.fontSize || 24).toString();\n            if (textColor)\n                textColor.value = selectedElement.color || '#2d3748';\n            boldBtn?.classList.toggle('active', selectedElement.fontWeight === 'bold');\n            italicBtn?.classList.toggle('active', selectedElement.fontStyle === 'italic');\n            const alignIndex = ['left', 'center', 'right'].indexOf(selectedElement.textAlign || 'left');\n            alignButtons.forEach((btn, i) => {\n                btn?.classList.toggle('active', i === alignIndex);\n            });\n        }\n        else {\n            this.textToolbar.style.display = 'none';\n        }\n    }\n    handleMouseDown(e) {\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        // Get element at global position\n        const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n        if (element) {\n            const selectedElement = this.globalManager.getSelectedElement();\n            const handle = selectedElement && element.id === selectedElement.id ?\n                this.getResizeHandle(localPoint, element) : null;\n            if (handle) {\n                this.resizeState = {\n                    isResizing: true,\n                    element: element,\n                    handle: handle,\n                    startPoint: globalPoint,\n                    originalBounds: {\n                        x: element.x,\n                        y: element.y,\n                        width: element.width,\n                        height: element.height,\n                        originalFontSize: element.fontSize\n                    }\n                };\n            }\n            else {\n                this.globalManager.setSelectedElement(element.id);\n                this.dragState = {\n                    isDragging: true,\n                    element: element,\n                    startPoint: globalPoint,\n                    elementStartPoint: { x: element.x, y: element.y }\n                };\n                this.updateTextToolbar();\n            }\n        }\n        else {\n            this.globalManager.setSelectedElement(null);\n            this.updateTextToolbar();\n        }\n        this.render();\n    }\n    handleMouseMove(e) {\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        if (this.resizeState.isResizing && this.resizeState.element) {\n            this.handleResize(globalPoint);\n        }\n        else if (this.dragState.isDragging && this.dragState.element) {\n            const dx = globalPoint.x - this.dragState.startPoint.x;\n            const dy = globalPoint.y - this.dragState.startPoint.y;\n            // Update element's global position\n            this.globalManager.updateElement(this.dragState.element.id, {\n                x: this.dragState.elementStartPoint.x + dx,\n                y: this.dragState.elementStartPoint.y + dy\n            });\n            // Trigger re-render on all canvases\n            document.dispatchEvent(new CustomEvent('element-moved'));\n        }\n        else {\n            const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n            const selectedElement = this.globalManager.getSelectedElement();\n            const handle = selectedElement && element && element.id === selectedElement.id ?\n                this.getResizeHandle(localPoint, element) : null;\n            this.canvas.style.cursor = handle ? this.getCursorForHandle(handle) : 'default';\n        }\n        this.render();\n    }\n    handleElementOverflow(element) {\n        // Emit event for multi-canvas manager to handle overflow\n        const event = new CustomEvent('element-overflow', {\n            detail: {\n                element: element,\n                canvasId: this.canvas.id,\n                bounds: {\n                    left: element.x,\n                    right: element.x + element.width,\n                    top: element.y,\n                    bottom: element.y + element.height\n                }\n            }\n        });\n        document.dispatchEvent(event);\n    }\n    handleResize(point) {\n        if (!this.resizeState.element || !this.resizeState.handle)\n            return;\n        const dx = point.x - this.resizeState.startPoint.x;\n        const dy = point.y - this.resizeState.startPoint.y;\n        const original = this.resizeState.originalBounds;\n        const element = this.resizeState.element;\n        // Check if it's a corner handle for proportional resizing\n        const isCorner = ['nw', 'ne', 'se', 'sw'].includes(this.resizeState.handle);\n        let updates = {};\n        if (isCorner) {\n            // Proportional resizing for corners\n            const aspectRatio = original.width / original.height;\n            let newWidth = original.width;\n            let newHeight = original.height;\n            switch (this.resizeState.handle) {\n                case 'nw':\n                    newWidth = original.width - dx;\n                    newHeight = newWidth / aspectRatio;\n                    updates.x = original.x + original.width - newWidth;\n                    updates.y = original.y + original.height - newHeight;\n                    break;\n                case 'ne':\n                    newWidth = original.width + dx;\n                    newHeight = newWidth / aspectRatio;\n                    updates.y = original.y + original.height - newHeight;\n                    break;\n                case 'se':\n                    newWidth = original.width + dx;\n                    newHeight = newWidth / aspectRatio;\n                    break;\n                case 'sw':\n                    newWidth = original.width - dx;\n                    newHeight = newWidth / aspectRatio;\n                    updates.x = original.x + original.width - newWidth;\n                    break;\n            }\n            updates.width = Math.max(20, newWidth);\n            updates.height = Math.max(20, newHeight);\n            // Scale font size for text elements\n            if (element.type === 'text' && element.fontSize) {\n                const scale = newWidth / original.width;\n                updates.fontSize = this.resizeState.originalBounds.originalFontSize * scale;\n            }\n        }\n        else {\n            // Free resizing for edge handles\n            switch (this.resizeState.handle) {\n                case 'n':\n                    updates.y = original.y + dy;\n                    updates.height = original.height - dy;\n                    break;\n                case 'e':\n                    updates.width = original.width + dx;\n                    break;\n                case 's':\n                    updates.height = original.height + dy;\n                    break;\n                case 'w':\n                    updates.x = original.x + dx;\n                    updates.width = original.width - dx;\n                    break;\n            }\n            if (updates.width !== undefined)\n                updates.width = Math.max(20, updates.width);\n            if (updates.height !== undefined)\n                updates.height = Math.max(20, updates.height);\n        }\n        // Update element through global manager\n        this.globalManager.updateElement(element.id, updates);\n        // Trigger re-render on all canvases\n        document.dispatchEvent(new CustomEvent('element-moved'));\n    }\n    getCursorForHandle(handle) {\n        const cursors = {\n            'nw': 'nw-resize',\n            'n': 'n-resize',\n            'ne': 'ne-resize',\n            'e': 'e-resize',\n            'se': 'se-resize',\n            's': 's-resize',\n            'sw': 'sw-resize',\n            'w': 'w-resize'\n        };\n        return cursors[handle];\n    }\n    getResizeHandle(localPoint, element) {\n        if (!element)\n            return null;\n        // Convert element global position to local for handle calculation\n        const localPos = this.globalToLocal(element.x, element.y);\n        const handleSize = 8 / this.scale;\n        const handles = [\n            { handle: 'nw', x: localPos.x, y: localPos.y },\n            { handle: 'n', x: localPos.x + element.width / 2, y: localPos.y },\n            { handle: 'ne', x: localPos.x + element.width, y: localPos.y },\n            { handle: 'e', x: localPos.x + element.width, y: localPos.y + element.height / 2 },\n            { handle: 'se', x: localPos.x + element.width, y: localPos.y + element.height },\n            { handle: 's', x: localPos.x + element.width / 2, y: localPos.y + element.height },\n            { handle: 'sw', x: localPos.x, y: localPos.y + element.height },\n            { handle: 'w', x: localPos.x, y: localPos.y + element.height / 2 }\n        ];\n        for (const h of handles) {\n            if (Math.abs(localPoint.x - h.x) <= handleSize &&\n                Math.abs(localPoint.y - h.y) <= handleSize) {\n                return h.handle;\n            }\n        }\n        return null;\n    }\n    handleMouseUp() {\n        this.dragState = {\n            isDragging: false,\n            element: null,\n            startPoint: { x: 0, y: 0 },\n            elementStartPoint: { x: 0, y: 0 }\n        };\n        this.resizeState = {\n            isResizing: false,\n            element: null,\n            handle: null,\n            startPoint: { x: 0, y: 0 },\n            originalBounds: { x: 0, y: 0, width: 0, height: 0 }\n        };\n    }\n    handleDoubleClick(e) {\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n        if (element && element.type === 'text') {\n            this.startInlineEditing(element);\n        }\n    }\n    startInlineEditing(element) {\n        if (element.type !== 'text')\n            return;\n        // Create a contentEditable div for inline editing\n        const editor = document.createElement('div');\n        editor.contentEditable = 'true';\n        editor.innerText = element.content;\n        editor.style.position = 'fixed';\n        // Calculate position based on canvas position and scale\n        const rect = this.canvas.getBoundingClientRect();\n        const container = this.canvas.parentElement?.getBoundingClientRect();\n        // Convert global element position to local canvas position\n        const localPos = this.globalToLocal(element.x, element.y);\n        // Adjust for container scroll if needed\n        const scrollLeft = this.canvas.parentElement?.scrollLeft || 0;\n        const scrollTop = this.canvas.parentElement?.scrollTop || 0;\n        editor.style.left = `${rect.left + (localPos.x - scrollLeft) * this.scale}px`;\n        editor.style.top = `${rect.top + (localPos.y - scrollTop) * this.scale}px`;\n        editor.style.minWidth = `${Math.max(100, element.width) * this.scale}px`;\n        editor.style.minHeight = `${element.height * this.scale}px`;\n        editor.style.maxWidth = `${(this.canvas.width - element.x) * this.scale}px`;\n        // Apply text styles exactly matching canvas\n        const style = element.fontStyle === 'italic' ? 'italic ' : '';\n        const weight = element.fontWeight === 'bold' ? 'bold ' : '';\n        editor.style.font = `${style}${weight}${(element.fontSize || 24) * this.scale}px ${element.fontFamily || 'Arial'}`;\n        editor.style.color = element.color || '#2d3748';\n        editor.style.textAlign = element.textAlign || 'left';\n        // Visual styles for better visibility\n        editor.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';\n        editor.style.border = '2px solid #3182ce';\n        editor.style.borderRadius = '4px';\n        editor.style.padding = `${5 * this.scale}px`;\n        editor.style.margin = '0';\n        editor.style.zIndex = '10000';\n        editor.style.whiteSpace = 'pre-wrap';\n        editor.style.wordBreak = 'break-word';\n        editor.style.overflow = 'auto';\n        editor.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';\n        // Line height to match canvas rendering\n        editor.style.lineHeight = '1.2';\n        // Hide the canvas text while editing\n        const originalContent = element.content;\n        this.globalManager.updateElement(element.id, { content: '' });\n        this.render();\n        document.body.appendChild(editor);\n        // Select all text\n        editor.focus();\n        const range = document.createRange();\n        range.selectNodeContents(editor);\n        const selection = window.getSelection();\n        if (selection) {\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n        let isFinished = false;\n        const finishEditing = () => {\n            if (isFinished)\n                return;\n            isFinished = true;\n            const newContent = editor.innerText.trim() || '텍스트';\n            this.globalManager.updateElement(element.id, { content: newContent });\n            if (document.body.contains(editor)) {\n                document.body.removeChild(editor);\n            }\n            // Update text dimensions based on new content\n            this.updateTextDimensions(element);\n            this.render();\n        };\n        const cancelEditing = () => {\n            if (isFinished)\n                return;\n            isFinished = true;\n            this.globalManager.updateElement(element.id, { content: originalContent });\n            if (document.body.contains(editor)) {\n                document.body.removeChild(editor);\n            }\n            this.render();\n        };\n        // Event handlers\n        editor.addEventListener('blur', finishEditing);\n        editor.addEventListener('keydown', (e) => {\n            if (e.key === 'Escape') {\n                e.preventDefault();\n                cancelEditing();\n            }\n            // Allow Enter for multi-line text\n            if (e.key === 'Tab') {\n                e.preventDefault();\n                finishEditing();\n            }\n        });\n        // Auto-resize as user types\n        editor.addEventListener('input', () => {\n            const newHeight = editor.scrollHeight;\n            if (newHeight > parseInt(editor.style.minHeight)) {\n                editor.style.height = `${newHeight}px`;\n            }\n        });\n        // Update position if canvas scrolls\n        const updatePosition = () => {\n            const rect = this.canvas.getBoundingClientRect();\n            const localPos = this.globalToLocal(element.x, element.y);\n            editor.style.left = `${rect.left + localPos.x * this.scale}px`;\n            editor.style.top = `${rect.top + localPos.y * this.scale}px`;\n        };\n        window.addEventListener('scroll', updatePosition);\n        window.addEventListener('resize', updatePosition);\n        // Clean up scroll listeners when done\n        const originalFinish = finishEditing;\n        const cleanup = () => {\n            window.removeEventListener('scroll', updatePosition);\n            window.removeEventListener('resize', updatePosition);\n        };\n        editor.addEventListener('blur', cleanup);\n    }\n    updateTextDimensions(element) {\n        if (element.type !== 'text')\n            return;\n        this.ctx.save();\n        const style = element.fontStyle === 'italic' ? 'italic ' : '';\n        const weight = element.fontWeight === 'bold' ? 'bold ' : '';\n        this.ctx.font = `${style}${weight}${element.fontSize}px ${element.fontFamily}`;\n        const metrics = this.ctx.measureText(element.content);\n        this.globalManager.updateElement(element.id, {\n            width: metrics.width + 20,\n            height: (element.fontSize || 24) * 1.5\n        });\n        this.ctx.restore();\n    }\n    getMousePosition(e) {\n        const rect = this.canvas.getBoundingClientRect();\n        const x = (e.clientX - rect.left) / this.scale;\n        const y = (e.clientY - rect.top) / this.scale;\n        return { x, y };\n    }\n    getElementAtPoint(localPoint) {\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        return this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n    }\n    addText(text = '텍스트') {\n        const baseFontSize = 24;\n        // Convert local center position to global position\n        const localCenter = {\n            x: this.canvas.width / 2 - 50,\n            y: this.canvas.height / 2 - baseFontSize / 2\n        };\n        const globalPos = this.localToGlobal(localCenter.x, localCenter.y);\n        const element = {\n            id: `element-${Date.now()}`,\n            type: 'text',\n            x: globalPos.x, // Global position\n            y: globalPos.y,\n            width: 200,\n            height: baseFontSize * 1.5,\n            content: text,\n            fontSize: baseFontSize,\n            fontFamily: 'Arial',\n            fontWeight: 'normal',\n            fontStyle: 'normal',\n            textAlign: 'left',\n            color: '#2d3748',\n            canvasId: this.canvas.id\n        };\n        this.globalManager.addElement(element);\n        this.globalManager.setSelectedElement(element.id);\n        this.updateTextToolbar();\n        this.render();\n        this.startInlineEditing(element);\n    }\n    addImage(imageUrl) {\n        const img = new Image();\n        img.onload = () => {\n            const maxSize = 300;\n            let width = img.width;\n            let height = img.height;\n            if (width > maxSize || height > maxSize) {\n                const ratio = Math.min(maxSize / width, maxSize / height);\n                width *= ratio;\n                height *= ratio;\n            }\n            // Convert local center position to global position\n            const localCenter = {\n                x: this.canvas.width / 2 - width / 2,\n                y: this.canvas.height / 2 - height / 2\n            };\n            const globalPos = this.localToGlobal(localCenter.x, localCenter.y);\n            const element = {\n                id: `element-${Date.now()}`,\n                type: 'image',\n                x: globalPos.x, // Global position\n                y: globalPos.y,\n                width: width,\n                height: height,\n                content: imageUrl,\n                imageElement: img,\n                canvasId: this.canvas.id\n            };\n            this.globalManager.addElement(element);\n            this.globalManager.setSelectedElement(element.id);\n            this.render();\n        };\n        img.src = imageUrl;\n    }\n    clear() {\n        // Clear all elements from global manager\n        this.globalManager.clearAll();\n        this.updateTextToolbar();\n        this.render();\n    }\n    deleteSelected() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement) {\n            this.globalManager.removeElement(selectedElement.id);\n            this.updateTextToolbar();\n            this.render();\n        }\n    }\n    render() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.fillStyle = 'white';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        // Get all elements that should be visible on this canvas\n        const visibleElements = this.globalManager.getElementsForCanvas(this.offsetX, this.offsetY, this.canvas.width, this.canvas.height);\n        // Render each visible element\n        for (const element of visibleElements) {\n            this.ctx.save();\n            // Set up clipping region to canvas bounds\n            this.ctx.beginPath();\n            this.ctx.rect(0, 0, this.canvas.width, this.canvas.height);\n            this.ctx.clip();\n            // Convert element's global position to local position for rendering\n            const localPos = this.globalToLocal(element.x, element.y);\n            const localElement = { ...element, x: localPos.x, y: localPos.y };\n            if (element.type === 'text') {\n                this.renderText(localElement);\n            }\n            else if (element.type === 'image' && element.imageElement) {\n                this.renderImage(localElement);\n            }\n            // Render selection if this element is selected\n            const selectedElement = this.globalManager.getSelectedElement();\n            if (selectedElement && element.id === selectedElement.id) {\n                this.renderSelection(localElement);\n                this.renderResizeHandles(localElement);\n            }\n            this.ctx.restore();\n        }\n    }\n    renderText(element) {\n        this.ctx.save();\n        const style = element.fontStyle === 'italic' ? 'italic ' : '';\n        const weight = element.fontWeight === 'bold' ? 'bold ' : '';\n        this.ctx.font = `${style}${weight}${element.fontSize}px ${element.fontFamily}`;\n        this.ctx.fillStyle = element.color || '#000000';\n        // Handle multi-line text\n        const lines = element.content.split('\\n');\n        const lineHeight = (element.fontSize || 24) * 1.2;\n        // Calculate total width and height\n        let maxWidth = 0;\n        lines.forEach(line => {\n            const metrics = this.ctx.measureText(line);\n            maxWidth = Math.max(maxWidth, metrics.width);\n        });\n        element.width = maxWidth + 10; // Reduced padding\n        element.height = lineHeight * lines.length;\n        // Render each line - allow rendering outside canvas bounds\n        lines.forEach((line, index) => {\n            let textX = element.x + 5;\n            if (element.textAlign === 'center') {\n                textX = element.x + element.width / 2;\n                this.ctx.textAlign = 'center';\n            }\n            else if (element.textAlign === 'right') {\n                textX = element.x + element.width - 5;\n                this.ctx.textAlign = 'right';\n            }\n            else {\n                this.ctx.textAlign = 'left';\n            }\n            const textY = element.y + lineHeight * (index + 0.5);\n            this.ctx.textBaseline = 'middle';\n            // Draw text even if it goes outside canvas bounds\n            this.ctx.fillText(line, textX, textY);\n        });\n        this.ctx.restore();\n    }\n    renderImage(element) {\n        if (element.imageElement) {\n            this.ctx.drawImage(element.imageElement, element.x, element.y, element.width, element.height);\n        }\n    }\n    renderSelection(element) {\n        this.ctx.strokeStyle = '#3182ce';\n        this.ctx.lineWidth = 2;\n        this.ctx.setLineDash([5, 5]);\n        this.ctx.strokeRect(element.x, element.y, element.width, element.height);\n        this.ctx.setLineDash([]);\n    }\n    renderResizeHandles(element) {\n        const handles = [\n            { x: element.x, y: element.y },\n            { x: element.x + element.width / 2, y: element.y },\n            { x: element.x + element.width, y: element.y },\n            { x: element.x + element.width, y: element.y + element.height / 2 },\n            { x: element.x + element.width, y: element.y + element.height },\n            { x: element.x + element.width / 2, y: element.y + element.height },\n            { x: element.x, y: element.y + element.height },\n            { x: element.x, y: element.y + element.height / 2 }\n        ];\n        this.ctx.fillStyle = '#3182ce';\n        this.ctx.strokeStyle = 'white';\n        this.ctx.lineWidth = 1;\n        handles.forEach(handle => {\n            this.ctx.fillRect(handle.x - 4, handle.y - 4, 8, 8);\n            this.ctx.strokeRect(handle.x - 4, handle.y - 4, 8, 8);\n        });\n    }\n    setupContextMenu() {\n        // Handle menu item clicks using event delegation\n        this.contextMenu.addEventListener('click', (e) => {\n            const target = e.target;\n            const menuItem = target.closest('.context-menu-item');\n            if (!menuItem || menuItem.classList.contains('has-submenu')) {\n                return;\n            }\n            e.stopPropagation();\n            const action = menuItem.dataset.action;\n            switch (action) {\n                case 'bring-front':\n                    this.bringToFront();\n                    break;\n                case 'bring-forward':\n                    this.bringForward();\n                    break;\n                case 'send-backward':\n                    this.sendBackward();\n                    break;\n                case 'send-back':\n                    this.sendToBack();\n                    break;\n                case 'duplicate':\n                    this.duplicateElement();\n                    break;\n                case 'copy':\n                    this.copyElement();\n                    break;\n                case 'paste':\n                    this.pasteElement();\n                    break;\n                case 'delete':\n                    this.deleteSelected();\n                    break;\n            }\n            this.contextMenu.style.display = 'none';\n            this.render();\n        });\n        // Prevent context menu from closing when hovering over submenu\n        this.contextMenu.addEventListener('contextmenu', (e) => {\n            e.preventDefault();\n        });\n    }\n    handleContextMenu(e) {\n        e.preventDefault();\n        const localPoint = this.getMousePosition(e);\n        const globalPoint = this.localToGlobal(localPoint.x, localPoint.y);\n        const element = this.globalManager.getElementAtPoint(globalPoint.x, globalPoint.y);\n        // Store click position for paste (in global coordinates)\n        this.lastContextMenuPosition = globalPoint;\n        if (element) {\n            // Show full menu for elements\n            this.globalManager.setSelectedElement(element.id);\n            this.updateTextToolbar();\n            // Show all menu items\n            const menuItems = this.contextMenu.querySelectorAll('.context-menu-item');\n            menuItems.forEach(item => {\n                item.style.display = '';\n            });\n            const separators = this.contextMenu.querySelectorAll('.context-menu-separator');\n            separators.forEach(sep => {\n                sep.style.display = '';\n            });\n        }\n        else {\n            // Show limited menu for empty space (only paste)\n            this.globalManager.setSelectedElement(null);\n            this.updateTextToolbar();\n            // Hide all items except paste\n            const menuItems = this.contextMenu.querySelectorAll('.context-menu-item');\n            menuItems.forEach(item => {\n                const action = item.dataset.action;\n                if (action === 'paste' && this.clipboard) {\n                    item.style.display = '';\n                }\n                else {\n                    item.style.display = 'none';\n                }\n            });\n            const separators = this.contextMenu.querySelectorAll('.context-menu-separator');\n            separators.forEach(sep => {\n                sep.style.display = 'none';\n            });\n        }\n        // Position context menu exactly at mouse cursor\n        this.contextMenu.style.left = `${e.clientX}px`;\n        this.contextMenu.style.top = `${e.clientY}px`;\n        this.contextMenu.style.display = 'block';\n        // Ensure menu stays within viewport\n        requestAnimationFrame(() => {\n            const menuRect = this.contextMenu.getBoundingClientRect();\n            let adjustedX = e.clientX;\n            let adjustedY = e.clientY;\n            // Adjust horizontal position if menu goes off right edge\n            if (menuRect.right > window.innerWidth) {\n                adjustedX = Math.max(0, window.innerWidth - menuRect.width - 5);\n            }\n            // Adjust vertical position if menu goes off bottom edge\n            if (menuRect.bottom > window.innerHeight) {\n                adjustedY = Math.max(0, window.innerHeight - menuRect.height - 5);\n            }\n            if (adjustedX !== e.clientX || adjustedY !== e.clientY) {\n                this.contextMenu.style.left = `${adjustedX}px`;\n                this.contextMenu.style.top = `${adjustedY}px`;\n            }\n        });\n        this.render();\n    }\n    bringToFront() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        this.globalManager.moveElementToFront(selectedElement.id);\n    }\n    bringForward() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        // For now, just move to front (can be improved with layer ordering)\n        this.globalManager.moveElementToFront(selectedElement.id);\n    }\n    sendBackward() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        // For now, just move to back (can be improved with layer ordering)\n        this.globalManager.moveElementToBack(selectedElement.id);\n    }\n    sendToBack() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (!selectedElement)\n            return;\n        this.globalManager.moveElementToBack(selectedElement.id);\n    }\n    copyElement() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement) {\n            this.clipboard = { ...selectedElement };\n        }\n    }\n    pasteElement() {\n        if (this.clipboard) {\n            const newElement = {\n                ...this.clipboard,\n                id: `element-${Date.now()}`,\n                x: this.lastContextMenuPosition.x || this.clipboard.x + 20,\n                y: this.lastContextMenuPosition.y || this.clipboard.y + 20,\n                canvasId: this.canvas.id\n            };\n            // If it's an image, clone the image element\n            if (newElement.type === 'image' && this.clipboard.imageElement) {\n                const img = new Image();\n                img.src = this.clipboard.imageElement.src;\n                newElement.imageElement = img;\n            }\n            this.globalManager.addElement(newElement);\n            this.globalManager.setSelectedElement(newElement.id);\n            this.updateTextToolbar();\n        }\n    }\n    duplicateElement() {\n        const selectedElement = this.globalManager.getSelectedElement();\n        if (selectedElement) {\n            const duplicate = this.globalManager.duplicateElement(selectedElement.id, 20, 20);\n            if (duplicate) {\n                this.globalManager.setSelectedElement(duplicate.id);\n                this.updateTextToolbar();\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/CanvasManager.ts?\n}");

/***/ }),

/***/ "./src/GlobalElementManager.ts":
/*!*************************************!*\
  !*** ./src/GlobalElementManager.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobalElementManager: () => (/* binding */ GlobalElementManager)\n/* harmony export */ });\nclass GlobalElementManager {\n    constructor() {\n        this.elements = new Map();\n        this.selectedElementId = null;\n    }\n    addElement(element) {\n        this.elements.set(element.id, element);\n    }\n    removeElement(elementId) {\n        this.elements.delete(elementId);\n        if (this.selectedElementId === elementId) {\n            this.selectedElementId = null;\n        }\n    }\n    getElement(elementId) {\n        return this.elements.get(elementId);\n    }\n    getAllElements() {\n        return Array.from(this.elements.values());\n    }\n    updateElement(elementId, updates) {\n        const element = this.elements.get(elementId);\n        if (element) {\n            Object.assign(element, updates);\n        }\n    }\n    getElementsForCanvas(canvasOffsetX, canvasOffsetY, canvasWidth, canvasHeight) {\n        const visibleElements = [];\n        this.elements.forEach(element => {\n            // Check if element intersects with this canvas\n            const elementRight = element.x + element.width;\n            const elementBottom = element.y + element.height;\n            const canvasRight = canvasOffsetX + canvasWidth;\n            const canvasBottom = canvasOffsetY + canvasHeight;\n            // Check for intersection\n            if (element.x < canvasRight &&\n                elementRight > canvasOffsetX &&\n                element.y < canvasBottom &&\n                elementBottom > canvasOffsetY) {\n                visibleElements.push(element);\n            }\n        });\n        return visibleElements;\n    }\n    setSelectedElement(elementId) {\n        this.selectedElementId = elementId;\n    }\n    getSelectedElement() {\n        if (this.selectedElementId) {\n            return this.elements.get(this.selectedElementId) || null;\n        }\n        return null;\n    }\n    clearAll() {\n        this.elements.clear();\n        this.selectedElementId = null;\n    }\n    duplicateElement(elementId, offsetX = 20, offsetY = 20) {\n        const original = this.elements.get(elementId);\n        if (!original)\n            return null;\n        const duplicate = {\n            ...original,\n            id: `element-${Date.now()}`,\n            x: original.x + offsetX,\n            y: original.y + offsetY\n        };\n        // Clone image element if needed\n        if (duplicate.type === 'image' && original.imageElement) {\n            const img = new Image();\n            img.src = original.imageElement.src;\n            duplicate.imageElement = img;\n        }\n        this.addElement(duplicate);\n        return duplicate;\n    }\n    getElementAtPoint(globalX, globalY) {\n        // Iterate in reverse to get topmost element\n        const elementsArray = Array.from(this.elements.values());\n        for (let i = elementsArray.length - 1; i >= 0; i--) {\n            const element = elementsArray[i];\n            if (globalX >= element.x &&\n                globalX <= element.x + element.width &&\n                globalY >= element.y &&\n                globalY <= element.y + element.height) {\n                return element;\n            }\n        }\n        return null;\n    }\n    moveElementToFront(elementId) {\n        const element = this.elements.get(elementId);\n        if (element) {\n            this.elements.delete(elementId);\n            this.elements.set(elementId, element);\n        }\n    }\n    moveElementToBack(elementId) {\n        const element = this.elements.get(elementId);\n        if (element) {\n            const allElements = Array.from(this.elements.entries());\n            this.elements.clear();\n            this.elements.set(elementId, element);\n            allElements.forEach(([id, el]) => {\n                if (id !== elementId) {\n                    this.elements.set(id, el);\n                }\n            });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/GlobalElementManager.ts?\n}");

/***/ }),

/***/ "./src/MultiCanvasManager.ts":
/*!***********************************!*\
  !*** ./src/MultiCanvasManager.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultiCanvasManager: () => (/* binding */ MultiCanvasManager)\n/* harmony export */ });\n/* harmony import */ var _CanvasManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanvasManager */ \"./src/CanvasManager.ts\");\n/* harmony import */ var _GlobalElementManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GlobalElementManager */ \"./src/GlobalElementManager.ts\");\n\n\nclass MultiCanvasManager {\n    constructor() {\n        this.canvases = new Map();\n        this.canvasDataMap = new Map();\n        this.activeCanvasId = null;\n        this.canvasCount = 0;\n        this.totalWidth = 0; // Track total width of all canvases\n        this.globalElementManager = new _GlobalElementManager__WEBPACK_IMPORTED_MODULE_1__.GlobalElementManager();\n        this.canvasContainer = document.getElementById('canvasContainer');\n        this.thumbnailContainer = document.getElementById('thumbnailContainer');\n        this.setupEventListeners();\n        // Create initial canvas\n        this.addCanvas();\n    }\n    setupEventListeners() {\n        const addCanvasBtn = document.getElementById('addCanvasBtn');\n        addCanvasBtn?.addEventListener('click', () => {\n            this.addCanvas();\n        });\n        // Listen for element movement to re-render all canvases\n        document.addEventListener('element-moved', () => {\n            this.renderAllCanvases();\n        });\n    }\n    renderAllCanvases() {\n        this.canvases.forEach(canvas => {\n            canvas.render();\n        });\n    }\n    handleElementOverflow(detail) {\n        const { element, canvasId, bounds } = detail;\n        const sourceCanvas = this.canvases.get(canvasId);\n        if (!sourceCanvas)\n            return;\n        // Get canvas position in container\n        const canvasWrapper = document.getElementById(`wrapper-${canvasId}`);\n        if (!canvasWrapper)\n            return;\n        const canvasRect = canvasWrapper.getBoundingClientRect();\n        const containerRect = this.canvasContainer.getBoundingClientRect();\n        // Check for adjacent canvases\n        this.canvases.forEach((targetCanvas, targetId) => {\n            if (targetId === canvasId)\n                return;\n            const targetWrapper = document.getElementById(`wrapper-${targetId}`);\n            if (!targetWrapper)\n                return;\n            const targetRect = targetWrapper.getBoundingClientRect();\n            // Check if element overflows into this canvas\n            if (this.isOverflowing(canvasRect, targetRect, bounds)) {\n                this.createOverflowElement(element, sourceCanvas, targetCanvas, canvasRect, targetRect);\n            }\n        });\n    }\n    isOverflowing(sourceRect, targetRect, bounds) {\n        // Check horizontal overflow (canvas is to the right)\n        if (targetRect.left >= sourceRect.right - 50 && bounds.right > sourceRect.width) {\n            return true;\n        }\n        // Check horizontal overflow (canvas is to the left)\n        if (targetRect.right <= sourceRect.left + 50 && bounds.left < 0) {\n            return true;\n        }\n        return false;\n    }\n    createOverflowElement(element, sourceCanvas, targetCanvas, sourceRect, targetRect) {\n        // Calculate relative position for the overflow element\n        const relativeX = element.x - (targetRect.left - sourceRect.left);\n        const relativeY = element.y;\n        // Create a temporary visual indicator (you can expand this to actually duplicate elements)\n        console.log('Element overflowing from', sourceCanvas.getCanvas().id, 'to', targetCanvas.getCanvas().id);\n    }\n    addCanvas() {\n        this.canvasCount++;\n        const canvasId = `canvas-${Date.now()}`;\n        const canvasName = `캔버스 ${this.canvasCount}`;\n        // Create canvas wrapper\n        const wrapper = document.createElement('div');\n        wrapper.className = 'canvas-wrapper';\n        wrapper.id = `wrapper-${canvasId}`;\n        // Create title\n        const title = document.createElement('div');\n        title.className = 'canvas-title';\n        title.contentEditable = 'true';\n        title.textContent = canvasName;\n        title.addEventListener('blur', () => {\n            const data = this.canvasDataMap.get(canvasId);\n            if (data) {\n                data.name = title.textContent || canvasName;\n                this.updateThumbnailLabel(canvasId, data.name);\n            }\n        });\n        // Create canvas element\n        const canvas = document.createElement('canvas');\n        canvas.id = canvasId;\n        wrapper.appendChild(title);\n        wrapper.appendChild(canvas);\n        this.canvasContainer.appendChild(wrapper);\n        // Calculate offset for this canvas (positioned horizontally)\n        const offsetX = this.totalWidth;\n        const offsetY = 0;\n        // Create CanvasManager instance with global manager and offset\n        const canvasManager = new _CanvasManager__WEBPACK_IMPORTED_MODULE_0__.CanvasManager(canvasId, this.globalElementManager, offsetX, offsetY);\n        this.canvases.set(canvasId, canvasManager);\n        // Store canvas data\n        const canvasData = {\n            id: canvasId,\n            name: canvasName,\n            width: 800,\n            height: 600,\n            offsetX: offsetX,\n            offsetY: offsetY\n        };\n        this.canvasDataMap.set(canvasId, canvasData);\n        // Update total width\n        this.totalWidth += 800 + 20; // Canvas width + gap\n        // Create thumbnail\n        this.createThumbnail(canvasId, canvasName);\n        // Set as active canvas\n        this.setActiveCanvas(canvasId);\n        // Scroll to the new canvas\n        wrapper.scrollIntoView({ behavior: 'smooth', inline: 'end' });\n    }\n    createThumbnail(canvasId, name) {\n        const thumbnailItem = document.createElement('div');\n        thumbnailItem.className = 'thumbnail-item';\n        thumbnailItem.id = `thumb-${canvasId}`;\n        // Create thumbnail canvas\n        const thumbCanvas = document.createElement('canvas');\n        thumbCanvas.className = 'thumbnail-canvas';\n        thumbCanvas.width = 120;\n        thumbCanvas.height = 90;\n        // Create label\n        const label = document.createElement('div');\n        label.className = 'thumbnail-label';\n        label.textContent = name;\n        // Create delete button\n        const deleteBtn = document.createElement('button');\n        deleteBtn.className = 'thumbnail-delete';\n        deleteBtn.innerHTML = '×';\n        deleteBtn.onclick = (e) => {\n            e.stopPropagation();\n            this.deleteCanvas(canvasId);\n        };\n        thumbnailItem.appendChild(thumbCanvas);\n        thumbnailItem.appendChild(label);\n        thumbnailItem.appendChild(deleteBtn);\n        // Add click handler\n        thumbnailItem.addEventListener('click', () => {\n            this.setActiveCanvas(canvasId);\n            const wrapper = document.getElementById(`wrapper-${canvasId}`);\n            wrapper?.scrollIntoView({ behavior: 'smooth', inline: 'center' });\n        });\n        this.thumbnailContainer.appendChild(thumbnailItem);\n    }\n    setActiveCanvas(canvasId) {\n        // Remove active class from all\n        document.querySelectorAll('.canvas-wrapper').forEach(wrapper => {\n            wrapper.classList.remove('active');\n        });\n        document.querySelectorAll('.thumbnail-item').forEach(thumb => {\n            thumb.classList.remove('active');\n        });\n        // Add active class to selected\n        const wrapper = document.getElementById(`wrapper-${canvasId}`);\n        const thumbnail = document.getElementById(`thumb-${canvasId}`);\n        wrapper?.classList.add('active');\n        thumbnail?.classList.add('active');\n        this.activeCanvasId = canvasId;\n        // Update thumbnail\n        this.updateThumbnail(canvasId);\n    }\n    updateThumbnail(canvasId) {\n        const canvasManager = this.canvases.get(canvasId);\n        const thumbnail = document.querySelector(`#thumb-${canvasId} .thumbnail-canvas`);\n        if (canvasManager && thumbnail) {\n            const sourceCanvas = document.getElementById(canvasId);\n            if (sourceCanvas) {\n                const ctx = thumbnail.getContext('2d');\n                if (ctx) {\n                    ctx.clearRect(0, 0, thumbnail.width, thumbnail.height);\n                    // Calculate scale to fit\n                    const scale = Math.min(thumbnail.width / sourceCanvas.width, thumbnail.height / sourceCanvas.height);\n                    const scaledWidth = sourceCanvas.width * scale;\n                    const scaledHeight = sourceCanvas.height * scale;\n                    const x = (thumbnail.width - scaledWidth) / 2;\n                    const y = (thumbnail.height - scaledHeight) / 2;\n                    ctx.drawImage(sourceCanvas, x, y, scaledWidth, scaledHeight);\n                }\n            }\n        }\n    }\n    updateThumbnailLabel(canvasId, name) {\n        const label = document.querySelector(`#thumb-${canvasId} .thumbnail-label`);\n        if (label) {\n            label.textContent = name;\n        }\n    }\n    deleteCanvas(canvasId) {\n        if (this.canvases.size <= 1) {\n            alert('최소 하나의 캔버스는 필요합니다.');\n            return;\n        }\n        if (confirm('이 캔버스를 삭제하시겠습니까?')) {\n            // Remove from maps\n            this.canvases.delete(canvasId);\n            this.canvasDataMap.delete(canvasId);\n            // Remove DOM elements\n            const wrapper = document.getElementById(`wrapper-${canvasId}`);\n            const thumbnail = document.getElementById(`thumb-${canvasId}`);\n            wrapper?.remove();\n            thumbnail?.remove();\n            // If this was the active canvas, select another\n            if (this.activeCanvasId === canvasId) {\n                const firstCanvasId = this.canvases.keys().next().value;\n                if (firstCanvasId) {\n                    this.setActiveCanvas(firstCanvasId);\n                }\n            }\n        }\n    }\n    getActiveCanvas() {\n        if (this.activeCanvasId) {\n            return this.canvases.get(this.activeCanvasId) || null;\n        }\n        return null;\n    }\n    updateAllThumbnails() {\n        this.canvases.forEach((_, canvasId) => {\n            this.updateThumbnail(canvasId);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/MultiCanvasManager.ts?\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n/* harmony import */ var _MultiCanvasManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MultiCanvasManager */ \"./src/MultiCanvasManager.ts\");\n\n\nclass App {\n    constructor() {\n        this.multiCanvasManager = new _MultiCanvasManager__WEBPACK_IMPORTED_MODULE_1__.MultiCanvasManager();\n        this.setupEventListeners();\n        // Update thumbnails periodically\n        setInterval(() => {\n            this.multiCanvasManager.updateAllThumbnails();\n        }, 1000);\n    }\n    setupEventListeners() {\n        const addTextBtn = document.getElementById('addTextBtn');\n        const imageUpload = document.getElementById('imageUpload');\n        const clearBtn = document.getElementById('clearBtn');\n        const canvasContainer = document.getElementById('canvasContainer');\n        const canvasWidth = document.getElementById('canvasWidth');\n        const canvasHeight = document.getElementById('canvasHeight');\n        const resolutionPreset = document.getElementById('resolutionPreset');\n        addTextBtn?.addEventListener('click', () => {\n            const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n            if (activeCanvas) {\n                activeCanvas.addText();\n            }\n        });\n        imageUpload?.addEventListener('change', (e) => {\n            const target = e.target;\n            const file = target.files?.[0];\n            if (file && file.type.startsWith('image/')) {\n                const reader = new FileReader();\n                reader.onload = (event) => {\n                    const imageUrl = event.target?.result;\n                    const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                    if (activeCanvas) {\n                        activeCanvas.addImage(imageUrl);\n                    }\n                };\n                reader.readAsDataURL(file);\n            }\n        });\n        clearBtn?.addEventListener('click', () => {\n            if (confirm('모든 요소를 삭제하시겠습니까?')) {\n                const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                if (activeCanvas) {\n                    activeCanvas.clear();\n                }\n            }\n        });\n        // Resolution change handlers\n        const applyResolution = () => {\n            const width = parseInt(canvasWidth.value);\n            const height = parseInt(canvasHeight.value);\n            if (width > 0 && height > 0) {\n                const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                if (activeCanvas) {\n                    activeCanvas.setResolution(width, height);\n                }\n            }\n        };\n        canvasWidth?.addEventListener('input', () => {\n            resolutionPreset.value = 'custom';\n            applyResolution();\n        });\n        canvasHeight?.addEventListener('input', () => {\n            resolutionPreset.value = 'custom';\n            applyResolution();\n        });\n        resolutionPreset?.addEventListener('change', () => {\n            const value = resolutionPreset.value;\n            if (value !== 'custom') {\n                const [width, height] = value.split('x').map(Number);\n                canvasWidth.value = width.toString();\n                canvasHeight.value = height.toString();\n                applyResolution();\n            }\n        });\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Delete' || e.key === 'Backspace') {\n                const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                if (activeCanvas) {\n                    activeCanvas.deleteSelected();\n                }\n            }\n        });\n        // Drag and drop for images\n        canvasContainer?.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            canvasContainer.classList.add('dragging');\n        });\n        canvasContainer?.addEventListener('dragleave', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            canvasContainer.classList.remove('dragging');\n        });\n        canvasContainer?.addEventListener('drop', (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            canvasContainer.classList.remove('dragging');\n            const files = e.dataTransfer?.files;\n            if (files) {\n                for (let i = 0; i < files.length; i++) {\n                    const file = files[i];\n                    if (file.type.startsWith('image/')) {\n                        const reader = new FileReader();\n                        reader.onload = (event) => {\n                            const imageUrl = event.target?.result;\n                            const activeCanvas = this.multiCanvasManager.getActiveCanvas();\n                            if (activeCanvas) {\n                                activeCanvas.addImage(imageUrl);\n                            }\n                        };\n                        reader.readAsDataURL(file);\n                    }\n                }\n            }\n        });\n    }\n}\ndocument.addEventListener('DOMContentLoaded', () => {\n    new App();\n});\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/index.ts?\n}");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://appstorescreenshot/./src/styles.css?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;